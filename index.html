<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Solana Rug Checker</title>
  <style>
    body {
      margin: 0; 
      padding: 0; 
      background-color: #0f0f0f; 
      color: #fff;
      font-family: Arial, sans-serif;
    }
    /* Container for both panels */
    .container {
      max-width: 1200px;
      margin: 2rem auto;
      display: flex;
      flex-wrap: wrap;
      gap: 2rem;
      padding: 0 1rem;
    }
    .left-panel, .right-panel {
      background: #151515;
      border-radius: 8px;
      padding: 1.5rem;
      flex: 1 1 300px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }

    /* Search Bar */
    .search-bar {
      max-width: 1200px;
      margin: 2rem auto 1rem;
      display: flex; 
      gap: 1rem; 
      padding: 0 1rem;
    }
    .search-bar input {
      flex: 1; 
      padding: 0.75rem; 
      font-size: 1rem; 
      border-radius: 6px;
      border: 1px solid #333; 
      background-color: #1c1c1c; 
      color: #fff;
    }
    .search-bar button {
      padding: 0.75rem 1.5rem; 
      border: none; 
      border-radius: 6px;
      background-color: #28a745; 
      color: #fff; 
      font-size: 1rem;
      cursor: pointer; 
      transition: background 0.3s;
    }
    .search-bar button:hover {
      background-color: #218838;
    }

    /* Left Panel (Token Info) */
    .token-header {
      display: flex; 
      align-items: center; 
      gap: 1rem; 
      margin-bottom: 1rem;
    }
    .token-logo {
      width: 48px; 
      height: 48px; 
      border-radius: 50%; 
      background: #333; 
      object-fit: cover;
    }
    .token-title {
      font-size: 1.5rem; 
      margin: 0;
      color: #28a745;
    }
    .token-info p {
      margin: 0.5rem 0;
    }
    .secure-label {
      color: #28a745;
      font-weight: bold;
    }
    .insecure-label {
      color: #dc3545;
      font-weight: bold;
    }

    /* Right Panel (Analysis) */
    .right-panel h2 {
      color: #28a745;
      margin-top: 0;
      margin-bottom: 1rem;
    }
    .analysis-score {
      display: flex; 
      align-items: center; 
      gap: 1rem; 
      margin-bottom: 1.5rem;
    }
    .analysis-circle {
      width: 80px; 
      height: 80px; 
      border-radius: 50%;
      background: #333; 
      display: flex; 
      align-items: center; 
      justify-content: center;
      font-size: 1.5rem; 
      font-weight: bold;
    }
    .analysis-label {
      font-size: 1.2rem; 
      font-weight: bold;
    }
    .analysis-sub {
      color: #ccc;
    }
    .risk-factors h3 {
      margin: 0.5rem 0;
    }
    .risk-circles {
      display: flex; 
      gap: 0.5rem; 
      margin-top: 0.5rem;
    }
    .risk-circle {
      width: 30px; 
      height: 30px; 
      border-radius: 50%;
      display: flex; 
      align-items: center; 
      justify-content: center;
      font-weight: bold; 
      color: #000;
    }
    .risk-circle.green {
      background: #28a745;
    }
    .risk-circle.yellow {
      background: #ffc107;
    }
    .risk-circle.red {
      background: #dc3545;
    }

    /* Responsive */
    @media(max-width: 800px) {
      .analysis-score {
        flex-direction: column; 
        align-items: flex-start;
      }
      .container {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>

<!-- Search Bar -->
<div class="search-bar">
  <input id="tokenAddress" type="text" placeholder="Enter token address" />
  <button onclick="rugCheck()">Rug Check</button>
</div>

<!-- Main Container -->
<div class="container">

  <!-- Left Panel: Token Info -->
  <div class="left-panel">
    <div class="token-header">
      <img id="tokenLogo" class="token-logo" src="" alt="Token Logo">
      <h2 id="tokenName" class="token-title">Unknown</h2>
    </div>
    <div class="token-info">
      <p><strong>Token Address:</strong> <span id="tokenAddr">--</span></p>
      <p><strong>Supply:</strong> <span id="tokenSupply">--</span></p>
      <p><strong>Mint Authority:</strong> <span id="mintAuth">--</span></p>
      <p><strong>Freeze Authority:</strong> <span id="freezeAuth">--</span></p>
      <p><strong>Social Links:</strong> <span id="socialLinks">No info found</span></p>

      <!-- NEW: Dev Sold line -->
      <p><strong>Dev Sold:</strong> <span id="devSold">N/A</span></p>
    </div>
  </div>

  <!-- Right Panel: Analysis -->
  <div class="right-panel">
    <h2>Token Safety Analysis</h2>
    <div class="analysis-score">
      <div class="analysis-circle" id="scoreCircle">--</div>
      <div>
        <div class="analysis-label" id="safetyStatus">Unknown</div>
        <div class="analysis-sub" id="scoreLabel">Safety Score: -- / 100</div>
      </div>
    </div>
    <div class="risk-factors">
      <h3>Risk Factor Count:</h3>
      <div class="risk-circles">
        <div class="risk-circle green" id="riskLow">0</div>
        <div class="risk-circle yellow" id="riskMed">0</div>
        <div class="risk-circle red" id="riskHigh">0</div>
      </div>
    </div>
  </div>

</div>

<!-- Pull in Solana Web3.js library -->
<script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>

<script>
  // Your Helius RPC Endpoint
  const RPC_ENDPOINT = "https://mainnet.helius-rpc.com/?api-key=f7f694d9-993a-46ba-adbf-3e1ec4f29416";
  
  // The "Dev" or "First Buyer" wallet address you want to check
  // Replace with the actual public key
  const DEV_WALLET_ADDRESS = "4z5N...REPLACE_WITH_ACTUAL_WALLET";

  // We'll load the official Solana Token List on page load
  let tokenList = [];
  let tokenListLoaded = false;

  window.addEventListener("DOMContentLoaded", async () => {
    try {
      const res = await fetch("https://raw.githubusercontent.com/solana-labs/token-list/main/src/tokens/solana.tokenlist.json");
      const data = await res.json();
      tokenList = data.tokens || [];
      tokenListLoaded = true;
      console.log("Token list loaded. Count:", tokenList.length);
    } catch (err) {
      console.error("Error loading token list:", err);
    }
  });

  async function rugCheck() {
    // If token list isn't loaded, let the user know
    if (!tokenListLoaded) {
      alert("Still loading the token list. Please wait a moment and try again!");
      return;
    }

    const inputAddr = document.getElementById('tokenAddress').value.trim();
    if (!inputAddr) {
      alert("Please enter a token address!");
      return;
    }
    let publicKey;
    try {
      publicKey = new solanaWeb3.PublicKey(inputAddr);
    } catch (err) {
      alert("Invalid Solana address!");
      return;
    }
    const fullAddress = publicKey.toBase58();

    // Reset UI
    resetUI(fullAddress);

    const connection = new solanaWeb3.Connection(RPC_ENDPOINT);

    try {
      // Attempt to find a token entry for the logo + name
      const tokenEntry = tokenList.find(t => t.address === fullAddress);

      if (tokenEntry) {
        document.getElementById("tokenName").textContent = tokenEntry.name || "Unknown";
        document.getElementById("tokenLogo").src = tokenEntry.logoURI || "https://via.placeholder.com/48/333/fff?text=No+Logo";
        
        // Attempt to parse social links from "extensions"
        if (tokenEntry.extensions) {
          const ex = tokenEntry.extensions;
          let links = [];
          if (ex.website) {
            links.push(`<a href="${ex.website}" target="_blank">Website</a>`);
          }
          if (ex.twitter) {
            const twitterHandle = ex.twitter.replace('@','');
            links.push(`<a href="https://twitter.com/${twitterHandle}" target="_blank">Twitter</a>`);
          }
          if (ex.discord) {
            links.push(`<a href="${ex.discord}" target="_blank">Discord</a>`);
          }
          if (ex.telegram) {
            links.push(`<a href="${ex.telegram}" target="_blank">Telegram</a>`);
          }
          if (links.length > 0) {
            document.getElementById("socialLinks").innerHTML = links.join(" | ");
          } else {
            document.getElementById("socialLinks").textContent = "No info found";
          }
        }
      } else {
        // Not found in token list
        document.getElementById("tokenName").textContent = "Unknown";
        document.getElementById("tokenLogo").src = "https://via.placeholder.com/48/333/fff?text=No+Logo";
      }

      // Let's fetch on-chain info
      const parsedInfo = await connection.getParsedAccountInfo(publicKey);

      let isMint = false;
      let isTokenAccount = false;
      let supply = "--";
      let mintAuth = "None";
      let freezeAuth = "None";

      if (parsedInfo.value && parsedInfo.value.data && parsedInfo.value.data.parsed) {
        const info = parsedInfo.value.data.parsed.info;
        const type = parsedInfo.value.data.parsed.type;
        
        if (type === "mint") {
          // It's a token mint
          isMint = true;
          supply       = info.supply;
          mintAuth     = info.mintAuthority   || "None";
          freezeAuth   = info.freezeAuthority || "None";
        } else if (type === "account") {
          // It's a token holding account
          isTokenAccount = true;
          mintAuth   = "(See Mint)";
          freezeAuth = "(See Mint)";
        }
      } else {
        // If not recognized as SPL token, fetch raw info
        const rawInfo = await connection.getAccountInfo(publicKey);
        if (!rawInfo) {
          console.log("No data found for", fullAddress);
        }
      }

      // If it's a mint, get more accurate supply
      if (isMint) {
        const tokenSupply = await connection.getTokenSupply(publicKey);
        if (tokenSupply.value) {
          supply = tokenSupply.value.amount;
        }
      }

      // Update left panel
      document.getElementById("tokenAddr").textContent    = shortenAddress(fullAddress);
      document.getElementById("tokenAddr").title          = fullAddress;
      document.getElementById("tokenSupply").textContent  = formatNumber(supply);
      document.getElementById("mintAuth").textContent     = (mintAuth === "None") 
        ? "Secure" : "Insecure";
      document.getElementById("mintAuth").className       = (mintAuth === "None") 
        ? "secure-label" : "insecure-label";
      document.getElementById("freezeAuth").textContent   = (freezeAuth === "None")
        ? "Secure" : "Insecure";
      document.getElementById("freezeAuth").className     = (freezeAuth === "None")
        ? "secure-label" : "insecure-label";

      // Compute Score + Risk Factors
      const { score, statusLabel, lowCount, medCount, highCount } 
        = computeScoreAndRisk({ isMint, isTokenAccount, supply, mintAuth, freezeAuth });

      // Update right panel
      document.getElementById("scoreCircle").textContent = score;
      document.getElementById("scoreLabel").textContent  = `Safety Score: ${score} / 100`;
      document.getElementById("safetyStatus").textContent= statusLabel;

      // Risk factor circles
      document.getElementById("riskLow").textContent  = lowCount;
      document.getElementById("riskMed").textContent  = medCount;
      document.getElementById("riskHigh").textContent = highCount;

      // NEW: Check if dev wallet sold
      if (isMint) {
        await checkDevSold(fullAddress, connection);
      } else {
        // If it's not a mint, we can't do a direct minted token check
        // We'll just say "N/A" or something
        document.getElementById("devSold").textContent = "N/A (Not a mint)";
      }

    } catch (err) {
      console.error(err);
      alert("Error fetching token info. Check console.");
    }
  }

  // Check if the dev wallet still holds the token
  async function checkDevSold(mintAddress, connection) {
    let devSoldEl = document.getElementById("devSold");
    try {
      // Convert dev wallet + mint to PublicKeys
      const devPublicKey  = new solanaWeb3.PublicKey(DEV_WALLET_ADDRESS);
      const mintPublicKey = new solanaWeb3.PublicKey(mintAddress);

      // Filter by the mint (so we only get token accounts for this mint)
      const tokenAccounts = await connection.getParsedTokenAccountsByOwner(
        devPublicKey,
        { mint: mintPublicKey }
      );

      if (!tokenAccounts.value || tokenAccounts.value.length === 0) {
        // Dev wallet has no token account for this mint => sold or never had it
        devSoldEl.textContent = "Yes (No account in dev wallet)";
        return;
      }

      // If we found an account, check the balance
      const acctData = tokenAccounts.value[0].account.data.parsed.info;
      const amount   = acctData.tokenAmount?.uiAmount || 0;
      if (amount > 0) {
        devSoldEl.textContent = "No (Still holding)";
      } else {
        devSoldEl.textContent = "Yes (Balance is zero)";
      }
    } catch (err) {
      console.error("Error checking dev sold:", err);
      devSoldEl.textContent = "Unknown";
    }
  }

  /* Placeholder logic for scoring + risk factor counts. 
     You can refine or add real logic for your project. */
  function computeScoreAndRisk({ isMint, isTokenAccount, supply, mintAuth, freezeAuth }) {
    let score = 50;
    let statusLabel = "Medium Risk";
    let lowCount = 0, medCount = 0, highCount = 0;

    if (isMint) {
      if (mintAuth === "None") {
        score += 30; 
        lowCount += 1;
      } else {
        score -= 20;
        highCount += 1;
      }
      if (freezeAuth === "None") {
        score += 10;
        lowCount += 1;
      } else {
        score -= 10;
        medCount += 1;
      }
    } else if (isTokenAccount) {
      score -= 5;
      medCount += 1;
    } else {
      score -= 10;
      highCount += 1;
    }

    const numSupply = parseFloat(supply);
    if (!isNaN(numSupply)) {
      if (numSupply > 1000000000) {
        score -= 10;
        medCount += 1;
      } else {
        score += 5;
        lowCount += 1;
      }
    }

    if (score < 0)   score = 0;
    if (score > 100) score = 100;

    if (score >= 80) {
      statusLabel = "Safe";
    } else if (score < 50) {
      statusLabel = "High Risk";
    }

    return { score, statusLabel, lowCount, medCount, highCount };
  }

  function resetUI(fullAddress) {
    document.getElementById("tokenName").textContent = "Unknown";
    document.getElementById("tokenLogo").src = "https://via.placeholder.com/48/333/fff?text=No+Logo";
    document.getElementById("tokenAddr").textContent = shortenAddress(fullAddress);
    document.getElementById("tokenAddr").title       = fullAddress;
    document.getElementById("tokenSupply").textContent = "--";
    document.getElementById("mintAuth").textContent    = "--";
    document.getElementById("freezeAuth").textContent  = "--";
    document.getElementById("mintAuth").className = "";
    document.getElementById("freezeAuth").className = "";
    document.getElementById("socialLinks").textContent = "No info found";
    document.getElementById("scoreCircle").textContent = "--";
    document.getElementById("scoreLabel").textContent  = "Safety Score: -- / 100";
    document.getElementById("safetyStatus").textContent= "Unknown";
    document.getElementById("riskLow").textContent  = "0";
    document.getElementById("riskMed").textContent  = "0";
    document.getElementById("riskHigh").textContent = "0";

    // Reset the "Dev Sold" line
    document.getElementById("devSold").textContent = "N/A";
  }

  // Shorten address to e.g. "mo7m...Wi5N"
  function shortenAddress(addr) {
    if (addr.length <= 8) return addr;
    return addr.slice(0,4) + "..." + addr.slice(-4);
  }

  // Format supply with commas
  function formatNumber(numStr) {
    if (numStr === "--") return "--";
    const n = parseFloat(numStr);
    if (isNaN(n)) return numStr;
    return n.toLocaleString();
  }
</script>
</body>
</html>
